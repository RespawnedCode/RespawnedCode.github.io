<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Professional Drawing App | RespawnedCode</title>
  <style>
    /* Reset and basics */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #f5f7fa;
      color: #333;
    }

    header {
      background: #1e2a38;
      color: #fff;
      padding: 1rem 2rem;
      text-align: center;
      font-weight: 600;
      font-size: 1.25rem;
    }

    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    #tools {
      width: 250px;
      background: #fff;
      border-right: 1px solid #ddd;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    #tools label {
      font-weight: 600;
      margin-bottom: 0.25rem;
      display: block;
    }

    button, input[type=range], input[type=color] {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 1rem;
      cursor: pointer;
      background: #fafafa;
      transition: background-color 0.2s ease;
    }
    button:hover {
      background: #e1e5ea;
    }

    #tools button.active {
      background-color: #1e2a38;
      color: white;
      font-weight: 700;
    }

    #canvas-container {
      flex: 1;
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    canvas {
      border: 1px solid #ccc;
      max-width: 100%;
      max-height: 100%;
      cursor: crosshair;
      background: white;
      touch-action: none; /* prevent scrolling on touch */
    }

    #gallery {
      background: #fff;
      border-left: 1px solid #ddd;
      width: 300px;
      padding: 1rem;
      overflow-y: auto;
    }

    #gallery h2 {
      margin-top: 0;
      font-weight: 600;
      font-size: 1.1rem;
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.5rem;
    }

    .thumb {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 0.75rem;
      cursor: pointer;
      position: relative;
    }

    .thumb img {
      width: 100%;
      display: block;
      border-radius: 4px;
    }

    .thumb button.delete {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(255, 0, 0, 0.8);
      border: none;
      color: white;
      font-weight: bold;
      border-radius: 2px;
      cursor: pointer;
      padding: 2px 6px;
      font-size: 0.8rem;
    }

    /* Responsive */
    @media (max-width: 900px) {
      main {
        flex-direction: column;
      }
      #tools, #gallery {
        width: 100%;
        height: 200px;
        overflow-x: auto;
        border-left: none !important;
        border-right: none !important;
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
      }
      #gallery {
        height: 150px;
      }
      #canvas-container {
        flex: 1 0 auto;
      }
    }
  </style>
</head>
<body>
  <header>RespawnedCode Professional Drawing App</header>
  <main>
    <section id="tools" aria-label="Drawing Tools">
      <label>Tool</label>
      <button id="brush" class="active" aria-pressed="true" title="Brush tool">Brush</button>
      <button id="eraser" aria-pressed="false" title="Eraser tool">Eraser</button>

      <label for="colorPicker">Color</label>
      <input type="color" id="colorPicker" value="#000000" aria-label="Choose brush color" />

      <label for="brushSize">Brush Size</label>
      <input type="range" id="brushSize" min="1" max="50" value="5" aria-valuemin="1" aria-valuemax="50" aria-valuenow="5" />

      <button id="undo" title="Undo last stroke">Undo</button>
      <button id="clear" title="Clear canvas">Clear Canvas</button>
      <button id="save" title="Save drawing to gallery">Save Drawing</button>
    </section>

    <section id="canvas-container" aria-label="Drawing Canvas">
      <canvas id="drawingCanvas" width="800" height="600" aria-label="Drawing area"></canvas>
    </section>

    <section id="gallery" aria-label="Saved Drawings Gallery">
      <h2>Gallery</h2>
      <div id="galleryItems"></div>
      <p id="emptyGallery" style="color:#777;">No saved drawings yet.</p>
    </section>
  </main>

  <script>
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const brushBtn = document.getElementById('brush');
    const eraserBtn = document.getElementById('eraser');
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const undoBtn = document.getElementById('undo');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');
    const galleryItems = document.getElementById('galleryItems');
    const emptyGallery = document.getElementById('emptyGallery');

    let drawing = false;
    let currentTool = 'brush';
    let strokes = [];
    let undoneStrokes = [];

    // Set initial brush settings
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = colorPicker.value;
    ctx.lineWidth = brushSize.value;

    // Store all drawing strokes as arrays of points
    // Stroke = { tool, color, size, points: [{x,y},...] }

    let currentStroke = null;

    function startDrawing(e) {
      drawing = true;
      undoneStrokes = []; // clear redo stack
      currentStroke = {
        tool: currentTool,
        color: ctx.strokeStyle,
        size: ctx.lineWidth,
        points: []
      };
      addPoint(e);
    }

    function addPoint(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      currentStroke.points.push({ x, y });
      redraw();
    }

    function stopDrawing() {
      if (!drawing) return;
      drawing = false;
      strokes.push(currentStroke);
      currentStroke = null;
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const stroke of strokes) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = stroke.tool === 'eraser' ? '#fff' : stroke.color;
        ctx.lineWidth = stroke.size;
        ctx.beginPath();
        stroke.points.forEach(({ x, y }, i) => {
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      // Draw current stroke
      if (currentStroke) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = currentStroke.tool === 'eraser' ? '#fff' : currentStroke.color;
        ctx.lineWidth = currentStroke.size;
        ctx.beginPath();
        currentStroke.points.forEach(({ x, y }, i) => {
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }
    }

    // Tool buttons events
    brushBtn.addEventListener('click', () => {
      currentTool = 'brush';
      ctx.strokeStyle = colorPicker.value;
      setActiveTool(brushBtn);
    });

    eraserBtn.addEventListener('click', () => {
      currentTool = 'eraser';
      setActiveTool(eraserBtn);
    });

    function setActiveTool(activeBtn) {
      [brushBtn, eraserBtn].forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-pressed', 'false');
      });
      activeBtn.classList.add('active');
      activeBtn.setAttribute('aria-pressed', 'true');
    }

    // Color picker changes brush color only if brush is selected
    colorPicker.addEventListener('input', () => {
      if (currentTool === 'brush') {
        ctx.strokeStyle = colorPicker.value;
      }
    });

    // Brush size change
    brushSize.addEventListener('input', () => {
      ctx.lineWidth = brushSize.value;
    });

    // Undo last stroke
    undoBtn.addEventListener('click', () => {
      if (strokes.length > 0) {
        undoneStrokes.push(strokes.pop());
        redraw();
      }
    });

    // Clear canvas
    clearBtn.addEventListener('click', () => {
      strokes = [];
      undoneStrokes = [];
      redraw();
    });

    // Save current canvas to gallery (localStorage)
    saveBtn.addEventListener('click', () => {
      if (strokes.length === 0) {
        alert('Nothing to save!');
        return;
      }
      const dataURL = canvas.toDataURL('image/png');
      let savedDrawings = JSON.parse(localStorage.getItem('drawings') || '[]');
      savedDrawings.push({ id: Date.now(), image: dataURL });
      localStorage.setItem('drawings', JSON.stringify(savedDrawings));
      loadGallery();
      alert('Drawing saved to gallery!');
    });

    // Load gallery from localStorage
    function loadGallery() {
      let savedDrawings = JSON.parse(localStorage.getItem('drawings') || '[]');
      galleryItems.innerHTML = '';
      if (savedDrawings.length === 0) {
        emptyGallery.style.display = 'block';
        return;
      }
      emptyGallery.style.display = 'none';
      for (const drawing of savedDrawings) {
        const div = document.createElement('div');
        div.classList.add('thumb');
        const img = document.createElement('img');
        img.src = drawing.image;
        img.alt = `Saved drawing ${drawing.id}`;
        div.appendChild(img);

        // Click on image loads it to canvas
        img.addEventListener('click', () => {
          loadDrawing(drawing.image);
        });

        // Delete button
        const delBtn = document.createElement('button');
        delBtn.classList.add('delete');
        delBtn.title = 'Delete drawing';
        delBtn.textContent = '×';
        delBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteDrawing(drawing.id);
        });
        div.appendChild(delBtn);

        galleryItems.appendChild(div);
      }
    }

    function loadDrawing(dataURL) {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        // Reset strokes, we lose vector info since we only load raster data
        strokes = [];
        undoneStrokes = [];
      };
      img.src = dataURL;
    }

    function deleteDrawing(id) {
      let savedDrawings = JSON.parse(localStorage.getItem('drawings') || '[]');
      savedDrawings = savedDrawings.filter(d => d.id !== id);
      localStorage.setItem('drawings', JSON.stringify(savedDrawings));
      loadGallery();
    }

    // Canvas event handlers
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('touchstart', startDrawing, { passive: false });

    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      addPoint(e);
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!drawing) return;
      addPoint(e);
    }, { passive: false });

    window.addEventListener('mouseup', stopDrawing);
    window.addEventListener('touchend', stopDrawing);

    // Initialize
    loadGallery();
  </script>
</body>
</html>
